<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Conversational Chatbot</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Configure Tailwind for a nice font and look -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary-blue': '#1c64f2',
                        'gemini-gray': '#e5e7eb',
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom styles for chat bubbles and scroll behavior */
        #chat-container {
            height: calc(100vh - 12rem); /* Full viewport height minus header and input */
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        /* Style for the loading indicator dot */
        .loading-dot {
            animation: bounce 0.6s infinite alternate;
        }
        .loading-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .loading-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-5px); }
        }
    </style>
</head>
<body class="bg-gray-50 font-sans h-screen flex flex-col antialiased">

    <!-- Chat Header -->
    <header class="p-4 bg-white border-b shadow-sm sticky top-0 z-10">
        <div class="max-w-4xl mx-auto flex items-center space-x-3">
            <svg class="w-8 h-8 text-primary-blue" fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm1.5 15h-3a.5.5 0 0 1-.5-.5v-4h-2a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h2V6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v10a.5.5 0 0 1-.5.5z"/>
                <path fill="#e5e7eb" d="M12.5 7h-1a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5z"/>
                <path d="M11 12.5h-2.5v1H11v-1zM14 10.5h-2.5v1H14v-1zM11 15.5h-2.5v1H11v-1zM14 8.5h-2.5v1H14v-1z"/>
            </svg>
            <h1 class="text-xl font-bold text-gray-800">Gemini Tutor</h1>
            <span class="text-sm text-gray-500 hidden sm:block">A helpful companion powered by the Gemini API.</span>
        </div>
    </header>

    <!-- Main Chat Area -->
    <main class="flex-grow max-w-4xl mx-auto w-full p-4 overflow-hidden">
        <div id="chat-container" class="space-y-4 pb-4">
            <!-- Initial Greeting Message -->
            <div class="flex justify-start">
                <div class="max-w-xs sm:max-w-lg p-3 rounded-lg bg-gemini-gray text-gray-800 shadow-md">
                    <p>Hello! I am your personal tutor. Ask me anything about science, history, or coding, and I'll do my best to help you learn!</p>
                </div>
            </div>
            <!-- Dynamic chat messages will be added here -->
        </div>
    </main>

    <!-- Input Area -->
    <footer class="p-4 bg-white border-t shadow-lg sticky bottom-0">
        <div class="max-w-4xl mx-auto">
            <form id="chat-form" class="flex space-x-3">
                <input type="text" id="user-input" placeholder="Type your message here..."
                       class="flex-grow p-3 border border-gray-300 rounded-xl focus:ring-primary-blue focus:border-primary-blue transition duration-150 shadow-inner"
                       autocomplete="off" required>
                <button type="submit" id="send-button"
                        class="px-6 py-3 bg-primary-blue text-white font-semibold rounded-xl hover:bg-blue-700 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg hover:shadow-xl">
                    Send
                </button>
            </form>
            <p class="text-xs text-gray-500 mt-2 text-center">
                *Calls are routed securely through the platform proxy.
            </p>
        </div>
    </footer>

    <script>
        // --- API & Core Setup ---
        // CRITICAL: For this environment, the apiKey must be an empty string. The platform handles the proxying securely.
        const apiKey = "AIzaSyB8PvuLvQzPALRo8YZ9vN_N-ZhP0mfZqDg"; 
        const API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/';
        const MODEL = 'gemini-2.5-flash-preview-09-2025';
        const API_URL = `${API_BASE_URL}${MODEL}:generateContent?key=${apiKey}`;

        // Elements
        const chatContainer = document.getElementById('chat-container');
        const chatForm = document.getElementById('chat-form');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');

        // --- Utility Functions ---

        // Function to create and append a new message bubble
        function appendMessage(sender, text) {
            const isUser = sender === 'user';
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex ${isUser ? 'justify-end' : 'justify-start'}`;

            const messageBubble = document.createElement('div');
            messageBubble.className = `max-w-xs sm:max-w-lg p-3 rounded-xl shadow-md ${
                isUser 
                ? 'bg-primary-blue text-white rounded-br-none' 
                : 'bg-gemini-gray text-gray-800 rounded-tl-none'
            }`;

            // Replace markdown newlines with <br> for better HTML rendering
            const formattedText = text.replace(/\n/g, '<br>');

            messageBubble.innerHTML = formattedText;
            messageWrapper.appendChild(messageBubble);
            chatContainer.appendChild(messageWrapper);

            // Scroll to the latest message
            chatContainer.scrollTop = chatContainer.scrollHeight;
            return messageBubble; // Return the bubble element for potential updates (like loading)
        }

        // Function to show a temporary loading indicator (the three dots)
        function showLoadingIndicator() {
            const loadingWrapper = document.createElement('div');
            loadingWrapper.id = 'loading-indicator';
            loadingWrapper.className = 'flex justify-start';

            loadingWrapper.innerHTML = `
                <div class="p-3 rounded-xl shadow-md bg-gemini-gray text-gray-800 rounded-tl-none">
                    <span class="inline-block w-2 h-2 mx-1 bg-primary-blue rounded-full loading-dot"></span>
                    <span class="inline-block w-2 h-2 mx-1 bg-primary-blue rounded-full loading-dot"></span>
                    <span class="inline-block w-2 h-2 mx-1 bg-primary-blue rounded-full loading-dot"></span>
                </div>
            `;
            chatContainer.appendChild(loadingWrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Function to remove the loading indicator
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            if (indicator) {
                indicator.remove();
            }
        }

        // --- API Call with Exponential Backoff ---

        async function fetchWithRetry(url, payload, maxRetries = 5) {
            let lastError = null;

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        return response;
                    }

                    // Log non-200 responses and retry (except for client errors like 4xx)
                    if (response.status >= 500 || response.status === 429) { // Server error or Rate Limit
                        lastError = `API Error: ${response.status} ${response.statusText}`;
                    } else {
                        // For other 4xx errors, don't retry, just fail fast
                        throw new Error(`API returned client error: ${response.statusText}`);
                    }

                } catch (error) {
                    lastError = error;
                }

                // Exponential backoff: 2^attempt seconds (1s, 2s, 4s, 8s, 16s...)
                const delay = Math.pow(2, attempt) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }

            throw new Error(`Failed to fetch content after ${maxRetries} attempts. Last error: ${lastError}`);
        }

        async function fetchGeminiResponse(userQuery) {
            const systemInstruction = "You are a friendly, concise, and helpful general knowledge tutor. Respond using simple, clear language. Do not use bold text unless absolutely necessary for clarity.";

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemInstruction }]
                },
                // Optional: Enable Google Search for grounding if needed
                tools: [{ "google_search": {} }],
            };

            try {
                const response = await fetchWithRetry(API_URL, payload);
                const result = await response.json();
                
                // Extract generated text
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!text) {
                     // If the model provides no text, it might be due to safety filters or a complex response structure.
                     return "Sorry, I was unable to generate a response for that query.";
                }

                // Extract citations (sources) if grounding was used
                let sourcesHtml = '';
                const groundingMetadata = result.candidates?.[0]?.groundingMetadata;

                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    const sources = groundingMetadata.groundingAttributions
                        .map(attribution => ({
                            uri: attribution.web?.uri,
                            title: attribution.web?.title,
                        }))
                        .filter(source => source.uri && source.title)
                        .slice(0, 3); // Limit to top 3 sources

                    if (sources.length > 0) {
                        const links = sources.map((s, index) => 
                            `<a href="${s.uri}" target="_blank" class="text-primary-blue hover:underline">${index + 1}</a>`
                        ).join(', ');

                        sourcesHtml = `<div class="mt-2 pt-2 border-t border-gray-300 text-xs text-gray-600">Sources: ${links}</div>`;
                    }
                }
                
                return text + sourcesHtml;

            } catch (error) {
                console.error("Gemini API Error:", error);
                return "Apologies, I encountered an error while contacting the AI. Please try again.";
            }
        }

        // --- Event Listener ---

        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const userQuery = userInput.value.trim();

            if (!userQuery) return;

            // 1. Display user message and clear input
            appendMessage('user', userQuery);
            userInput.value = '';

            // 2. Disable input and show loading
            sendButton.disabled = true;
            userInput.disabled = true;
            showLoadingIndicator();

            // 3. Fetch response
            const aiResponseHtml = await fetchGeminiResponse(userQuery);

            // 4. Remove loading and display AI message
            hideLoadingIndicator();
            appendMessage('gemini', aiResponseHtml);

            // 5. Re-enable input
            sendButton.disabled = false;
            userInput.disabled = false;
            userInput.focus();
        });
        
        // Focus the input field on load
        window.onload = () => {
             userInput.focus();
        }

    </script>
</body>
</html>
